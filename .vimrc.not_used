" ==============================================
" Plugins which it may come into use someday... {{{
" ==============================================
" vimshell {{{
" Use shell in vim # not necessary on GNU screen
NeoBundleLazy 'Shougo/vimshell', {
  \ 'autoload' : { 'commands' : [ 'VimShell', "VimShellPop", "VimShellInteractive" ] }}
" }}} vimshell

" vim-reunions {{{
" For asynchronous process
"NeoBundle "osyo-manga/vim-reunions"
" }}} vim-reunions

" vim-smartchr {{{
" Toggle insert words
" * Example is for ' = ', ' == ', '='
" * maybe it can be used more useful way, but now it it nos used.
NeoBundle "kana/vim-smartchr"

if s:neobundle_enable && ! empty(neobundle#get("vim-smartchr"))
  inoremap <buffer><expr> = smartchr#one_of(' = ', ' == ', '=')
endif
" }}} vim-smartchr

" rainbow_parentheses {{{
" Highlight bracket
" * Sometime conflicts with other file syntax
" * (e.g. markdown syntax for URL)
NeoBundle "kien/rainbow_parentheses.vim"

if s:neobundle_enable && ! empty(neobundle#get("rainbow_parentheses.vim"))
  "let g:rbpt_colorpairs = [
  "    \ ['brown',       'RoyalBlue3'],
  "    \ ['Darkblue',    'SeaGreen3'],
  "    \ ['darkgray',    'DarkOrchid3'],
  "    \ ['darkgreen',   'firebrick3'],
  "    \ ['darkcyan',    'RoyalBlue3'],
  "    \ ['darkred',     'SeaGreen3'],
  "    \ ['darkmagenta', 'DarkOrchid3'],
  "    \ ['brown',       'firebrick3'],
  "    \ ['gray',        'RoyalBlue3'],
  "    \ ['black',       'SeaGreen3'],
  "    \ ['darkmagenta', 'DarkOrchid3'],
  "    \ ['Darkblue',    'firebrick3'],
  "    \ ['darkgreen',   'RoyalBlue3'],
  "    \ ['darkcyan',    'SeaGreen3'],
  "    \ ['darkred',     'DarkOrchid3'],
  "    \ ['red',         'firebrick3'],
  "    \ ]
  let g:rbpt_loadcmd_toggle = 0
  let g:rbpt_max = 16
  au VimEnter * RainbowParenthesesToggle
  au Syntax * RainbowParenthesesLoadRound
  au Syntax * RainbowParenthesesLoadSquare
  au Syntax * RainbowParenthesesLoadBraces
endif
" }}} rainbow_parentheses

" clang_complete{{{
NeoBundleLazy "Rip-Rip/clang_complete", {
  \"autoload" : { "filetypes" : ["c", "cpp"] }}

if s:neobundle_enable && ! empty(neobundle#get("lang_complete"))
  "g:clang_use_library = 1
  "g:clang_complete_auto = 0
endif
" }}} clang_complete

" }}} Plugins which it may come into use someday...

" =========================
" Currenlty, not necessary {{{
" =========================

" Basic Settings {{{
if has("windows")
  scriptencoding cp932 " sjis
  set fileencodings=iso-2022-jp,euc-jp,sjis,utf-8
else " if has("unix") || has("mac")
  set fileencodings=iso-2022-jp,euc-jp,sjis,ucs-bom,default,latin1,utf-8
endif
if has("gui_running") && !has("unix")
  set encoding=utf-8
endif
set encoding=utf8
set encoding=cp932
set fileencodings=iso-2022-jp,euc-jp,sjis,utf-8
set fileencodings=iso-2022-jp,euc-jp,sjis,ucs-bom,default,latin1,utf-8
autocmd MyAutoGroup FileType vbs :set fileencoding=sjis
autocmd MyAutoGroup FileType vbs :set encoding=sjis

" Automatic ime off
" noimdisableactivate was dumped from the latest MacVim?
" noimdisable should be used instead.
" but it seems not necessary anyway (all IME related things are done in KeyRemap4MacBook.
if has("mac")
  set noimdisableactivate
endif

" Set current directory as a directory of the file
autocmd MyAutoGroup BufEnter *   execute ":lcd " . expand("%:p:h")

" INSERT (paste)
set paste " use 'paste at normal mode' in below, instead

" }}}

" map (for other than each plugin) {{{
" fix meta-keys which generate <Esc>a .. <Esc>z
let c='a'
while c <= 'z'
  "exec "set <M-".toupper(c).">=\e".c
  "exec "imap \e".c." <M-".toupper(c).">"
  "let c = nr2char(1+char2nr(c))
endw
for i in map(
    \   range(char2nr("a"), char2nr("z"))
    \ + range(char2nr("A"), char2nr("Z"))
    \ + range(char2nr("0"), char2nr("9"))
    \ , "nr2char(v:val)")
  " <ESC>O do not map because used by arrow keys.
  if i != "O"
    execute "nmap <ESC>" . i "<M-" . i . ">"
  endif
endfor

" fix meta-keys each
nmap <ESC>h <M-h>
nmap <ESC>j <M-j>
nmap <ESC>k <M-k>
nmap <ESC>l <M-l>

" Don't use Ex mode, use Q for formatting
map Q gq

""" normal mode (noremap)

" Window move
nnoremap <M-h> <C-w><<CR>
nnoremap <M-j> <C-w>+<CR>
nnoremap <M-k> <C-w>-<CR>
nnoremap <M-l> <C-w>><CR>
nnoremap <D-h> <C-w><<CR>
nnoremap <D-j> <C-w>+<CR>
nnoremap <D-k> <C-w>-<CR>
nnoremap <D-l> <C-w>><CR>

" stop highlight for search
" can't use C-/ ?
nnoremap <C-/> :noh<CR>
" this makes something wrong
" at start when using vim w/o screen...
nnoremap <Esc> :noh<CR>
" Esc mapping may be used others,
" better to use others...
nnoremap <silent> <Esc><Esc> :noh<CR>

" direct indent
" this makes trouble at visual mode (indent twice for current line)
nnoremap > >>
nnoremap < <<

" don't register single letter by x
" * fixed at FileType autocmd
nnoremap x "_x " set in virtualedit

" window
" * not work, because <C-c> cancels the command
nnoremap <C-w><C-c> <C-w><C-c>

" Open vimrc (is <C-u> necessary for command map?
nnoremap <Leader><Leader> :<C-u>tabedit $MYVIMRC<CR>

""" insert mode (inoremap)

" insert file/directory name
" -> Use <C-o><Leader>f, instead
inoremap <silent> <Leader>f <CR><Esc><BS>:r!echo %<CR>i<BS><Esc>Jxi
inoremap <silent> <Leader>f <C-R>%
inoremap <silent> <Leader>d <CR><Esc><BS>:r!echo %:p:h<CR>i<BS><Esc>Jxi

" -> use smartinput
" < can't be used for mapping?
" (maybe < has special means in vim scripts and need special treatment)
inoremap <> <><Left>
inoremap '' ''<Left>
inoremap "" ""<Left>
inoremap () ()<Left>
inoremap [] []<Left>
inoremap {} {}<Left>

inoremap < <><Left>
"inoremap ' ''<Left>
"inoremap " ""<Left>
inoremap ( ()<Left>
inoremap [ []<Left>
inoremap { {}<Left>

""" visual mode (vnoremap)

"  is not necessary?
" -> use to surround
vnoremap { "zdi{<C-R>z}<Esc>
vnoremap [ "zdi[<C-R>z]<Esc>
vnoremap ( "zdi(<C-R>z)<Esc>
vnoremap " "zdi"<C-R>z"<Esc>
vnoremap ' "zdi'<C-R>z'<Esc>

" open .vimrc when starting w/o argument {{{
autocmd VimEnter * nested if @% == "" && s:GetBufByte() == 0 | edit $MYVIMRC | endif
function! s:GetBufByte()
    let byte = line2byte(line("$") + 1)
    if byte == -1
        return 0
    else
        return byte - 1
    endif
endfunction
" }}}

" }}}

" unite sources {{{
" Source for unite: colorscheme
" * ':colorscheme' command is enough (Tab shows candidates)
NeoBundle 'ujihisa/unite-colorscheme'
" Source for unite: font
" * Only for gui
NeoBundle 'ujihisa/unite-font'

" }}}

" vim-auto-save {{{
" * normally, it is better to save by hand.
"NeoBundle "vim-scripts/vim-auto-save"

if s:neobundle_enable && ! empty(neobundle#get("vim-auto-save"))
  " auto save interval is 'updatetime'(=200 ms as default)
  let g:auto_save = 1

endif
" }}} vim-auto-save

" vim-quickrun {{{
" * Not necessary on GNU sceen...
NeoBundleLazy "thinca/vim-quickrun", { "autoload" : {
  \ "mappings" : [
  \ ["nxo", "<Plug>(quickrun)"]] }}
" }}}

" for hl_matchit {{{
" Vim plugin to highlight matchit.vim
" # Make it too slow especially for files which have many brackets
" # It can match such "if" in vimrc
" # But it seems too much...
NeoBundle "vimtaku/hl_matchit.vim"

if s:neobundle_enable && ! empty(neobundle#get("hl_matchit.vim"))
  let g:hl_matchit_enable_on_vim_startup = 1
  let g:hl_matchit_hl_groupname = 'Title'
  let g:hl_matchit_allow_ft_regexp = 'html\|vim\|ruby\|sh'
endif
" }}} hl_matchit

" YankRing {{{
" Easy to use history of yanks (see below settings)
" * Strange behavior (couse it map all y/d/c/x)
NeoBundle "vim-scripts/YankRing.vim"

if s:neobundle_enable && ! empty(neobundle#get("YankRing.vim"))
  nnoremap <Leader>y :YRShow<CR>
  " avoid to store single letter to normal register
  let g:yankring_history_dir=g:vimdir
  "let g:yankring_n_keys = 'Y D' " Y D x X
  "let g:yankring_enabled=0 " 1
  let g:yankring_max_history=50 " 100
  let g:yankring_max_display=50 " 500
  "let g:yankring_ignore_duplicate=0 " 1
  let g:yankring_dot_repeat_yank=1
  let g:yankring_clipboard_monitor=0 " 1
  let g:yankring_min_element_length=2 " 1, :skip all single letter copy
  "let g:yankring_persist=0 " 1
  "let g:yankring_share_between_instances=0 " 1
  "let g:yankring_window_use_separate=0 " 1
  "let g:yankring_window_use_horiz=0
  "let g:yankring_window_auto_close=0 " 1
  let g:yankring_window_width=50 " 30
  "let g:yankring_window_use_right=0 " 1
  "let g:yankring_window_increment=15 " 1
  let g:yankring_manage_numbered_reg = 1 " 0
  "let g:yankring_paste_check_default_register = 0 "1

  " for warning :The yankring can only persist if the viminfo setting has a !
  "set viminfo+=!
endif
" }}} YankRing

" vim-yankstack {{{
" Yank stack (similar as YankRing)
" * same as YankRing, it map y/d/c/x...
NeoBundle "maxbrunsfeld/vim-yankstack"

if s:neobundle_enable && ! empty(neobundle#get("vim-yankstack"))
  nmap <M-p> <Plug>yankstack_substitute_older_paste
  nmap <M-n> <Plug>yankstack_substitute_newer_paste
endif
" }}} vim-yankstack

" yanktmp {{{
" Use yanks in different processes (see below settings)
" * It can yank only a line
" * replaced by own setting
NeoBundle "yanktmp.vim"

if s:neobundle_enable && ! empty(neobundle#get("yanktmp.vim"))
  let g:yanktmp_file = $HOME."/.vim/vimyanktmp"

  " yanktmp prefix
  noremap [yanktmp] <Nop>
  map s [yanktmp]

  " show buffer
  noremap <silent> [yanktmp]y :call YanktmpYank()<CR>
  noremap <silent> [yanktmp]p :call YanktmpPaste_p()<CR>
  noremap <silent> [yanktmp]P :call YanktmpPaste_P()<CR>
endif
" }}} yanktmp

" savevers {{{
" File Edit History
" * Make several backup file named *.clean, to follow history easily.
" * Not so useful when persistent_undo is enabled,
" * but rather it makes things complex as it makes too many '.clean' files...
NeoBundle "savevers.vim"

if s:neobundle_enable && ! empty(neobundle#get("savevers.vim"))
  set patchmode=.clean
  set backup
  let savevers_types = "*"
  let savevers_dirs = &backupdir
  let versdiff_no_resize=1
  nmap <silent> <F5> :VersDiff -<cr>
  nmap <silent> <F6> :VersDiff +<cr>
  nmap <silent> <F8> :VersDiff -c<cr>
endif
" }}}

" undotree {{{
" Another undo, need vim7.3+patch005
" Use gundo instead
NeoBundle "mbbill/undotree"

if s:neobundle_enable && ! empty(neobundle#get("undotree"))
  nmap <Leader>U :UndotreeToggle<CR>
  let g:undotree_SetFocusWhenToggle = 1
  let g:undotree_SplitLocation = "topleft"
  let g:undotree_SplitWidth = 35
  let g:undotree_diffAutoOpen = 1
  let g:undotree_diffpanelHeight = 25
  let g:undotree_RelativeTimestamp = 1
  let g:undotree_TreeNodeShape = "*"
  let g:undotree_HighlightChangedText = 1
  let g:undotree_HighlightSyntax = "UnderLined"
endif
" }}}

" Align {{{
" Align codes
" http://www.drchip.org/astronaut/vim/align.html#Examples
" * Use 'h1mesuke/vim-alignta' instead
NeoBundle "Align"
" }}} Align

" vim-surround {{{
" Each to change surround
" * use original surround.vim
NeoBundle "anyakichi/vim-surround"
if s:neobundle_enable && (! empty(neobundle#get("surround.vim")) || ! empty(neobundle#get("vim-surround")))
  "
endif
" }}}

" vim-pcompleteowerline {{{
" Cool Status Line
" * Use lightline
NeoBundle "Lokaltog/vim-pcompleteowerline"
" }}}

" vim-airline{{{
" Another status line
" * Use lightlin
NeoBundle "bling/vim-airline"

" inu/nuco
"NeoBundle "osyo-manga/vim-airline-inu"
"NeoBundle "osyo-manga/vim-airline-nuko"

if s:neobundle_enable && ! empty(neobundle#get("vim-airline"))
  let g:airline_left_sep=''
  let g:airline_right_sep=''
  let g:airline_inactive_collapse=1
  let g:airline_theme="bubblegum"
  let g:airline_section_z="%4l/%L:%3c"
endif
"}}} vim-airline

" vim-insert-linenr {{{
" Highlight line number
" * Line number is not used...
NeoBundle 'cohama/vim-insert-linenr'
" }}}

" vim-seek {{{
" Jump to letters (two letters) after "s"
" * / (search) or easymoting can be alternatives...
NeoBundle "goldfeld/vim-seek"
" }}}

" Visual-Mark {{{
" visualize marks
" * unite + unite-mark is an alternative
NeoBundle "Visual-Mark"

if s:neobundle_enable && ! empty(neobundle#get("Visual-Mark"))
  " Visual Mark prefix
  nnoremap [vmark] <Nop>
  nmap <Leader>v [vmark]
  nmap <silent> [vmark]v <Plug>Vm_toggle_sign
  nmap <silent> [vmark]j <Plug>Vm_goto_next_sign
  nmap <silent> [vmark]k <Plug>Vm_goto_prev_sign
  " submot doesn't work?
  "if ! empty(neobundle#get("vim-submode"))
  "  call submode#enter_with("visualmark", "n", "", ",vj", "<Plug>Vm_goto_next_sign")
  "  call submode#enter_with("visualmark", "n", "", ",vk", "<Plug>Vm_goto_prev_sign")
  "  call submode#map("visualmark", "n", "", ",vj", "<Plug>Vm_goto_next_sign")
  "  call submode#map("visualmark", "n", "", ",vk", "<Plug>V<Leader>m_goto_prev_sign")
  "  call submode#map("visualmark", "n", "", "vj", "<Plug>Vm<Leader>_goto_next_sign")
  "  call submode#map("visualmark", "n", "", "vk", "<Plug>Vm_goto_prev_sign")
  "  call submode#map("visualmark", "n", "", "j", "<Plug>Vm_goto_next_sign")
  "  call submode#map("visualmark", "n", "", "k", "<Plug>Vm_goto_prev_sign")
  "endif
endif
" }}} surround.vim

" Gmail{{{
NeoBundleLazy "yuratomo/gmail.vim",{
  \ "autoload" : {"commands": ["Gmail"]},
  \ "depends" : ["Shougo/vimproc"]}

if s:neobundle_enable && ! empty(neobundle#get("gmail.vim"))
  let g:gmail_imap = "imap.gmail.com:993"
  let g:gmail_smtp = "smtp.gmail.com:465"
  " path for openssl
  let &path = $path."/usr/bin"
  if filereadable(expand("$HOME/.Gmail.vim"))
    source $HOME/.Gmail.vim
  endif
endif
" }}} Gmail

" SimpleNote{{{
NeoBundleLazy "mattn/vimplenote-vim",{
  \ "autoload" : {"commands": ["VimpleNote"]}}
if s:neobundle_enable && ! empty(neobundle#get("simplenote.vim"))
  " for simplenote.vim
  "let g:SimplenoteUsername = ""
  "let g:SimplenotePassword = """
  if filereadable(expand("$HOME/.Simplenote.vim"))
    source $HOME/.Simplenote.vim
  endif
endif

NeoBundleLazy "mrtazz/simplenote.vim",{
  \ "autoload" : {"commands": ["Simplenote"]}}
if s:neobundle_enable && ! empty(neobundle#get("vimplenote-vim"))
  " for vimplenote-vim
  "let g:VimpleNoteUsername = ""
  "let g:VimpleNotePassword = ""
  " move to $HOME/.VimpleNote
  if filereadable(expand("$HOME/.VimpleNote.vim"))
    " in vimplenote/autoload/vimplenote.vim:get_email(),
    " email must be input even if VimpleNoteUsername was defined,
    " because it checks self.token, it is always 0 here...
    source $HOME/.VimpleNote.vim
  endif
  function! Sn()
    VimpleNote -l
    wincmd w
    wincmd q
  endfunction
endif
" }}} Simplenote

" Evernte {{{
" evernote: need markdown library...
NeoBundleLazy "kakkyz81/evervim",{
  \ "autoload" : {"commands": ["EvervimNotebookList", "EvervimListTags",
  \                            "EvervimSearchByQuery", "EvervimCreateNote",
  \                            "EvervimOpenBrowser", "EvervimSetup"]}}
" }}}

" gitgutter{{{
" Show added/deleted/modified line for git
" * Use signify, which can do for svn or others in addiiton to git
NeoBundleLazy "airblade/vim-gitgutter", {
  \ "autoload": { "commands": ["GitGutterEnable","GitGutterToggle"]}}

if s:neobundle_enable && ! empty(neobundle#get("vim-gitgutter"))
  nnoremap <Leader>g :GitGutterToggle<CR>
endif
"}}} gitgutter

" Changed {{{
" Displays signs on changed lines
" Use signify
NeoBundleLazy "Changed", {
  \ "autoload": {"commands": ["Changed"]}}
}
" }}}

" vim-singleton {{{
" Don't launch new vim instance
" * for Gvim heavy user?
NeoBundle "thinca/vim-singleton"
" }}}

" splash{{{
" show what you like on start-up
NeoBundle "thinca/vim-splash"

if s:neobundle_enable && ! empty(neobundle#get("vim-splash"))
  let g:splash#path = $HOME . "/.vimrc"
endif
"}}} splash

" File Explorer {{{
" * Use SrcExpl

" ctrlp {{{
NeoBundle "kien/ctrlp.vim"
if s:neobundle_enable && ! empty(neobundle#get("ctrlp.vim"))
  "let g:ctrlp_map = "<c-p>"
endif
"}}} ctrlp

NeoBundle "scrooloose/nerdtree"
NeoBundle "trinity.vim"
NeoBundle "The-NERD-tree"
NeoBundle "Source-Explorer-srcexpl.vim"
NeoBundle "mru.vim"
" }}}

" Tags {{{
" taglist{{{
NeoBundle "taglist.vim"
if s:neobundle_enable && ! empty(neobundle#get("taglist.vim"))
  set tags=tags
  "let Tlist_Ctags_Cmd = "/usr/bin/ctags"
  let Tlist_Show_One_File = 1
  let Tlist_Use_Right_Window = 1
  let Tlist_Exit_OnlyWindow = 1
  nnoremap <silent> <leader>l :TlistToggle<CR>
endif
"}}} taglist

eoBundle "ctags.vim"
" }}}

" Color scheme {{{
NeoBundle "ujihisa/unite-colorscheme"
NeoBundle "tomasr/molokai"
colorscheme molokai
NeoBundle "nanotech/jellybeans.vim"
NeoBundle "altercation/vim-colors-solarized"
NeoBundle "vim-scripts/newspaper.vim"
NeoBundle "w0ng/vim-hybrid"
NeoBundle "noahfrederick/vim-hemisu"
"colorscheme blue
" }}}

" jekyll.vim{{{
" these commands are not necessary to be done in vim
NeoBundle "csexton/jekyll.vim"

if s:neobundle_enable && ! empty(neobundle#get("jekyll.vim"))
  let g:jekyll_path = "~/Dropbox/05_WebService/octopress/source/"
endif
"}}} applescript

" octopress {{{
" Highlight for octopress
" * vim-markdown is rather good (no syntax for jekyll?)
NeoBundle "tangledhelix/vim-octopress"

if s:neobundle_enable && ! empty(neobundle#get("vim-octopress"))
  autocmd BufNewFile,BufRead *.md,*.textile set filetype=octopress
endif
"}}} octopress

" JavaScript {{{
" * Something wrong at buffer change
NeoBundle "marijnh/tern_for_vim"
"}}}

" QuickBuf {{{
" bufffer management
" Unite is enough?

NeoBundle "QuickBuf"

if s:neobundle_enable && ! empty(neobundle#get("QuickBuf"))
  let g:qb_hotkey = "<Subleader>b"
endif
"}}} QuickBuf

" clever-f {{{
" Can use f instead of ;, after fx move
" Can move even to other lines
" * annoying at making macros...
NeoBundle "rhysd/clever-f.vim"
"}}}



" }}} Currenlty, not necessary

" ==========================================
" Unused/Obsolete settings for used plugins {{{
" ==========================================

" NeoBundle {{{
" Installation check.
if neobundle#exists_not_installed_bundles()
  echomsg "Not installed bundles : " .
    \ string(neobundle#get_not_installed_bundle_names())
  NeoBundleInstall
endif
" }}}

" vim-smartinput {{{
NeoBundle "kana/vim-smartinput"

if s:neobundle_enable && ! empty(neobundle#get("vim-smartinput"))
  " Remove spaces at the end of line
  " * Replaced by: nnoremap <Leader><Space>  :%s/<Space>\+$//g<CR><C-o>
  call smartinput#define_rule({
  \   'at': '\s\+\%#',
  \   'char': '<CR>',
  \   'input': '<C-o>:call setline('.', substitute(getline('.'), '\\s\\+$', '', ''))<CR><CR>',
  \   })
endif
" }}}

" syntastic {{{
NeoBundle "scrooloose/syntastic", {
  \ "build": {
  \   "windows": ["pip install flake8", "npm -g install coffeelint"],
  \   "cygwin": ["pip install flake8", "npm -g install coffeelint"],
  \   "mac": ["pip install flake8", "npm -g install coffeelint"],
  \   "unix": ["pip install flake8", "npm -g install coffeelint"] }}
" }}}

" }}} Unused/Obsolete settings for used plugins

" ==========================================
" Tips {{{
" ==========================================
"" # startup tips
"" * start w/o vimrc
""     vim -u NONE
"" * start w/o viminfo
""     vim -i NONE
"" * start w/o X connection
""     vim -X
"" * write startup timing to startup.log
""     vim --startuptime startup.log
""
"" # check configurations
"" * default commands (mappings)
""     :help index.txt
"" * my mappings
""     :nmap " show mappings for normal mode
"" *show mappings for normal mode with name of file
""  in which the mapping is defined
""     :verbose nmap
"" * for boolean parameters, use '?'
""     :verbose wrap?
""
"" # mapping
"" * leader: default <leader> = \
"" but leader can be changed by
""     let mapleader = ","
"" * special arguments:<silent>,<buffer>, etc...
""     :no a <silent> echo 'hoge'<CR>
"" it doesn't show cmmands/results in command line (so above does nothing)
""     :no a <buffer>... effective in the current buffer only
""
""
"" # Command line
"" * shell command
""     :! echo current file is %
"" % will be replaced by name of current file
""
"" * Insert command result
""     :r ! echo % " insert current file name
""     :r ! echo %:p " full path of file
""     :r ! echo %:h " insert current directory (relative)
""     :r ! echo %:p:h " insert current directory (absolute)
""     :r ! echo expand(%:p:h) " expand such '~'
""     :r !ls "files/directories in current directory
""
""
""
"" # Completion
""     i_C-X_C-F -> file name completion
""     i_C-X_C-K -> dictionary completion
""     i_C-V_tab -> insert tab
""     i_C-R_%   -> insert current file name
""        other C-R usages
""        '"'     the unnamed register, containing the text of
""                the last delete or yank
""        '%'     the current file name
""        '#'     the alternate file name
""        '*'     the clipboard contents (X11: primary selection)
""        '+'     the clipboard contents
""        '/'     the last search pattern
""        ':'     the last command-line
""        '-'     the last small (less than a line) delete
""        '.'     the last inserted text
""                                        *c_CTRL-R_=*
""        '='     the expression register: you are prompted to
""                enter an expression (see |expression|)
""                (doesn't work at the expression prompt; some
""                things such as changing the buffer or current
""
"" # vimdiff (vim -d)
"" * Open files
""     vimdiff file1 file2 [file3 [file4]]
"" * Open vimdiff during editing with vim
""     :vertical diffsplit filename
""     vimdiff file1 file2 [file3 [file4]]
"" * Go to Next Diff
""     [c
"" * Go to Previous Diff
""     ]c
"" * Copy current buffer's structure to another structure
""     do
"" * Copy another's buffer's structure to current structure
""     dp
"" * Diff to original when it was opened
""   :DiffOrig
"" * Stop diff
""   :diffoff
"" * Update diff
""   :diffupdate
""
"" # Register
"" * Show words in register
""     :reg
"" * Others
""   *Unnamed (") register is used for all copy/delete
""   *0 register is only used for copy
""   *"0p makes it possible to paste what you copied
""    even after you deleted something
""   ** register is used for clipboard
""   */ is used for word used for searching
""   *"ayy registers current line to register a
""   *"ap copies a register in normal mode
""   *<C-R>" : copy unnamed register in insert mode
""   *<C-R>a : copy a register in insert mode
""
"" # buffer
"" * show buffers
""     :ls
"" * go to next buffer, previous buffer
""     :bn , :bp
"" * go to buffer N
""     :b N or N<C-^>
""
"" # spell check
"" * suggest correct words
""     z=
"" * next missspelled word
""     ]s
"" * previous missspelled word
""     [s
"" * add word under the cursor to good word list file
""     zg
"" * add word under the cursor to good internal-wordlis
""     zG
"" * mark word under the cursor as bad, remove word from good word list file
""     zw
"" * mark word under the cursor as bad, remove word from good internal-wordlist
""     zW
""
"" * undo zg/G/w/W
""    zug/zuG/zuw/zuW
""
"" # undo/redo
"" * show tree
""   :undol[ist]
"" * Go to older/newer
""   g-/g+
"" * Go to older/newer with arguments
""   earlier/later
" }}} Tips

" vim: foldmethod=marker
" vim: foldmarker={{{,}}}
" vim: foldlevel=0
